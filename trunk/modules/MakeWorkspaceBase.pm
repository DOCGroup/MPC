package MakeWorkspaceBase;

# ************************************************************
# Description   : A Make Workspace base module
# Author        : Chad Elliott
# Create Date   : 11/21/2006
# ************************************************************

# ************************************************************
# Pragmas
# ************************************************************

use strict;

# ************************************************************
# Subroutine Section
# ************************************************************

sub workspace_file_prefix {
  #my($self) = shift;
  return 'Makefile';
}


sub workspace_file_extension {
  #my($self) = shift;
  return '';
}


sub supports_make_coexistence {
  my($self) = shift;
  return ($self->workspace_file_extension() ne '');
}


sub workspace_file_name {
  my($self) = shift;
  return $self->get_modified_workspace_name(
                                 $self->workspace_file_prefix(),
                                 $self->make_coexistence() ?
                                     $self->workspace_file_extension() : '');
}


sub workspace_per_project {
  #my($self) = shift;
  return 1;
}


sub workspace_preamble {
  my($self) = shift;
  my($fh)   = shift;
  my($crlf) = shift;
  my($name) = shift;
  my($id)   = shift;

  print $fh '#----------------------------------------------------------------------------', $crlf,
            '#       ', $name, $crlf,
            '#', $crlf,
            '# ', $id, $crlf,
            '#', $crlf,
            '# This file was generated by MPC.  Any changes made directly to', $crlf,
            '# this file will be lost the next time it is generated.', $crlf,
            '#', $crlf,
            '# MPC Command:', $crlf,
            '# ', $self->create_command_line_string($0, @ARGV), $crlf,
            '#', $crlf,
            '#----------------------------------------------------------------------------', $crlf,
            $crlf;
}


sub write_named_targets {
  my($self)    = shift;
  my($fh)      = shift;
  my($crlf)    = shift;
  my($targnum) = shift;
  my($list)    = shift;
  my($remain)  = shift;
  my($targpre) = shift;
  my($allpre)  = shift;
  my($trans)   = shift;
  my($phony)   = shift;
  my($andsym)  = shift;
  my($maxline) = shift;

  ## Print out the "all" target
  if (defined $maxline) {
    my($all) = 'all:';
    foreach my $project (@$list) {
      $all .= " $$trans{$project}";
    }
    if (length($all) < $maxline) {
      print $fh $crlf, $all;
    }
    else {
      $remain = 'all ' . $remain;
    }
  }
  else {
    print $fh $crlf . 'all:';
    foreach my $project (@$list) {
      print $fh " $$trans{$project}";
    }
  }

  ## Print out all other targets here  
  print $fh "$crlf$crlf$remain:$crlf";
  $self->write_project_targets($fh, $crlf,
                               $targpre . '$(@)', $list, $andsym);

  ## Print out each target separately
  foreach my $project (@$list) {
    print $fh ($phony ? "$crlf.PHONY: $$trans{$project}" : ''),
              $crlf, $$trans{$project}, ':';
    if (defined $$targnum{$project}) {
      foreach my $number (@{$$targnum{$project}}) {
        print $fh " $$trans{$$list[$number]}";
      }
    }  
    print $fh $crlf;
    $self->write_project_targets($fh, $crlf,
                                 $targpre . $allpre . 'all',
                                 [ $project ], $andsym);
  }

  ## Print out the project_name_list target
  print $fh $crlf, "project_name_list:$crlf";
  foreach my $project (sort @$list) {
    print $fh "\t\@echo $$trans{$project}$crlf";
  }
}

1;
